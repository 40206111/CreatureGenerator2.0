// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SkinGridKernal

struct PointData
{
	float3 pos;
	float rad;
};

struct CubeData
{
    float4 cubeVertex1;
    float4 cubeVertex2;
    float4 cubeVertex3;
    float4 cubeVertex4;
    float4 cubeVertex5;
    float4 cubeVertex6;
    float4 cubeVertex7;
    float4 cubeVertex8;
};

RWStructuredBuffer<CubeData> _MarchingCubes;

StructuredBuffer<PointData> _SkelePoints;

float _GridDivisions;

float GetIsInSphere(float3 vertex, PointData skelePoint)
{
    return length(vertex - skelePoint.pos) + _GridDivisions * 0.1f <= skelePoint.rad;
}

CubeData MakeGridCube(float3 startingPoint, PointData pointData)
{
    float x = startingPoint.x;
    float y = startingPoint.y;
    float z = startingPoint.z;
    float3 cubePositions[8];
    cubePositions[0] = float3(x, y, z + _GridDivisions);
    cubePositions[1] = float3(x + _GridDivisions, y, z + _GridDivisions);
    cubePositions[2] = float3(x + _GridDivisions, y, z);
    cubePositions[3] = float3(startingPoint);
    cubePositions[4] = float3(x, y + _GridDivisions, z + _GridDivisions);
    cubePositions[5] = float3(x + _GridDivisions, y + _GridDivisions, z + _GridDivisions);
    cubePositions[6] = float3(x + _GridDivisions, y + _GridDivisions, z);
    cubePositions[7] = float3(x, y + _GridDivisions, z);

    CubeData cube;
    cube.cubeVertex1 = float4(cubePositions[0], GetIsInSphere(cubePositions[0], pointData));
    cube.cubeVertex2 = float4(cubePositions[1], GetIsInSphere(cubePositions[1], pointData));
    cube.cubeVertex3 = float4(cubePositions[2], GetIsInSphere(cubePositions[2], pointData));
    cube.cubeVertex4 = float4(cubePositions[3], GetIsInSphere(cubePositions[3], pointData));
    cube.cubeVertex5 = float4(cubePositions[4], GetIsInSphere(cubePositions[4], pointData));
    cube.cubeVertex6 = float4(cubePositions[5], GetIsInSphere(cubePositions[5], pointData));
    cube.cubeVertex7 = float4(cubePositions[6], GetIsInSphere(cubePositions[6], pointData));
    cube.cubeVertex8 = float4(cubePositions[7], GetIsInSphere(cubePositions[7], pointData));

    return cube;
}

void CreateGrid(PointData pointData)
{
    float3 pos = pointData.pos;
    float rad = pointData.rad;
    float3 startPoint = float3(pos.x - rad, pos.y - rad, pos.z - rad);
    float divisionsPerUnit = 1.0 / _GridDivisions;
    float3 gridVec = float3(_GridDivisions, _GridDivisions, _GridDivisions);
    startPoint.x = floor(divisionsPerUnit * startPoint.x) / divisionsPerUnit;
    startPoint.y = floor(divisionsPerUnit * startPoint.y) / divisionsPerUnit;
    startPoint.z = floor(divisionsPerUnit * startPoint.z) / divisionsPerUnit;

    startPoint -= gridVec;

    float3 endPoint = float3(pos.x + rad, pos.y + rad, pos.z + rad);
    endPoint.x = ceil(divisionsPerUnit * endPoint.x) / divisionsPerUnit;
    endPoint.y = ceil(divisionsPerUnit * endPoint.y) / divisionsPerUnit;
    endPoint.z = ceil(divisionsPerUnit * endPoint.z) / divisionsPerUnit;

    endPoint += gridVec;

    int cubeSideLenX = (int)((endPoint.x - startPoint.x) / _GridDivisions);
    int cubeSideLenY = (int)((endPoint.y - startPoint.y) / _GridDivisions);
    int cubeSideLenZ = (int)((endPoint.z - startPoint.z) / _GridDivisions);

    for (int x = 0; x < cubeSideLenX; ++x)
    {
        for (int y = 0; y < cubeSideLenY; ++y)
        {
            for (int z = 0; z < cubeSideLenZ; ++z)
            {
                float3 cubeOrigin = float3(x, y, z) * _GridDivisions;
                cubeOrigin = startPoint + cubeOrigin;
                _MarchingCubes[x + y * cubeSideLenX + z * cubeSideLenX * cubeSideLenY] = MakeGridCube(cubeOrigin, pointData);
            }
        }
    }
}

[numthreads(8,8,1)]
void SkinGridKernal(uint id : SV_DispatchThreadID)
{
    PointData pointData = _SkelePoints[id];
	CreateGrid( pointData );
}